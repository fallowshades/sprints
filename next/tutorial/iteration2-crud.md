#

##

- read what is

[Prisma sqlite](https://www.prisma.io/docs/concepts/database-connectors/sqlite)

- type safe
- auto generated api

(Prisma Instance)[https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution]

[services]
instance

- does clerk need all segments? (OPTIONAL ALSO hmm)
- hot module reload

[crud-naive]

- for action and hidden id input.

- safely applies and tracks changes to the database structure.

```sh
npx prisma migrate dev
```

- in a new terminal window
- launch Prisma Studio, which is a visual editor for your database.
- http://localhost:5555

```sh
npx prisma studio
```

## setup services

### More Routing

- Private Folders
  \_folder
- Route Groups
  (dashboard)
- Dynamic Routes

  - [...folder] - Catch-all route segment
  - [[...folder]] Optional catch-all route segment (used by Clerk)

- create test folder app/\_css
- create app/(dashboard)/auth

  - the url is just '/auth'

- create app/(dashboard)/auth/[sign-in]

```js
const SignInPage = ({ params }) => {
  console.log(params)
  return <div>SignInPage</div>
}
export default SignInPage
```

- create app/(dashboard)/auth/[...sign-in]
- create app/(dashboard)/auth/[[...sign-in]]

### Prisma

- install prisma vs-code extension

[Prisma sqlite](https://www.prisma.io/docs/concepts/database-connectors/sqlite)

Prisma ORM is a database toolkit that simplifies database access in web applications. It allows developers to interact with databases using a type-safe and auto-generated API, making database operations easier and more secure.

- Prisma server: A standalone infrastructure component sitting on top of your database.
- Prisma client: An auto-generated library that connects to the Prisma server and lets you read, write and stream data in your database. It is used for data access in your applications.

```sh
npm install prisma --save-dev
npm install @prisma/client
```

```sh
npx prisma init
```

This creates a new prisma directory with your Prisma schema file and configures SQLite as your database. You're now ready to model your data and create your database with some tables.

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
```

- ADD .ENV TO .GITIGNORE !!!!

.env

```js
DATABASE_URL = 'file:./dev.db'
```

### Setup Instance

In development, the command next dev clears Node.js cache on run. This in turn initializes a new PrismaClient instance each time due to hot reloading that creates a connection to the database. This can quickly exhaust the database connections as each PrismaClient instance holds its own connection pool.

(Prisma Instance)[https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution]

- create utils/db.ts

```js
import { PrismaClient } from '@prisma/client';

const prismaClientSingleton = () => {
  return new PrismaClient();
};

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClientSingleton | undefined;
};

const prisma = globalForPrisma.prisma ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

### Create Model

```prisma
model Task {
  id String @id @default(uuid())
  content String
  createdAt DateTime @default(now())
  completed Boolean @default(false)
}
```

- safely applies and tracks changes to the database structure.

```sh
npx prisma migrate dev
```

- in a new terminal window
- launch Prisma Studio, which is a visual editor for your database.
- http://localhost:5555

```sh
npx prisma studio
```

#### Prisma Model

The Prisma model provided is a representation of a Task entity in the context of a database schema. Here's a detailed description of each component within this model:

model Task { ... }: This is the definition of the Task model. In Prisma, a model represents a table in the database. It serves as a blueprint for the records that will be stored in the corresponding table, defining the structure and behavior of the data.

id String @id @default(uuid()): This line defines a field named id of type String which is marked with @id, signifying that this field is the primary key of the model. The @default(uuid()) directive indicates that the default value for this field will be a UUID (Universally Unique Identifier) generated by Prisma.

content String: This line declares a field named content of type String. This field will store textual data, presumably the details or description of the task.

createdAt DateTime @default(now()): This field is named createdAt and is of type DateTime. It has a default value set to the current timestamp at the time of record creation, indicated by the @default(now()) directive.

completed Boolean @default(false): Lastly, the completed field is of type Boolean and is used to indicate whether the task has been completed. It defaults to false, meaning when a new task record is created, it is considered incomplete by default.

In Prisma, the term "model" refers to an abstraction that maps to a table in your database. Prisma models are defined in the Prisma schema, which is a declarative representation of your database's structure. Each model in the Prisma schema corresponds to a table in the database, and each field within a model corresponds to a column in that table. This schema plays a central role in Prisma's features, such as type-safe database access and migrations.

### Prisma Example

- remove query
- fix the links the navbar

```js
import prisma from '@/utils/db'

const prismaHandlers = async () => {
  await prisma.task.create({
    data: {
      content: 'wake up',
    },
  })
  const allTasks = await prisma.task.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  })

  return allTasks
}

const Prisma = async () => {
  const tasks = await prismaHandlers()
  return (
    <div>
      <h1 className='text-3xl font-medium mb-4'>Prisma Example </h1>
      {tasks.map((task) => {
        return (
          <h2 key={task.id} className='text-xl py-2'>
            ðŸ˜¬ {task.content}
          </h2>
        )
      })}
    </div>
  )
}
export default Prisma
```

##

## Optional - Prisma Crud

[Prisma Docs](https://www.prisma.io/docs/concepts/components/prisma-client/crud)

- Create Single Record

```js
const task = await prisma.task.create({
  data: {
    content: 'some task',
  },
})
```

- Get All Records

```js
const tasks = await prisma.task.findMany()
```

- Get record by ID or unique identifier

```js
// By unique identifier
const user = await prisma.user.findUnique({
  where: {
    email: 'elsa@prisma.io',
  },
})

// By ID
const task = await prisma.task.findUnique({
  where: {
    id: id,
  },
})
```

- Update Record

```js
const updateTask = await prisma.task.update({
  where: {
    id: id,
  },
  data: {
    content: 'updated task',
  },
})
```

- Update or create records

```js
const upsertTask = await prisma.task.upsert({
  where: {
    id: id,
  },
  update: {
    content: 'some value',
  },
  create: {
    content: 'some value',
  },
})
```

- Delete a single record

```js
const deleteTask = await prisma.task.delete({
  where: {
    id: id,
  },
})
```

## Challenge - Display Tasks

- create TaskForm, TaskList, DeleteForm components
- render them in tasks page
- in TaskList render all tasks
- also display editBtn and DeleteForm
- editBtn - link to single task page
- reference the complete project

tasks/page.js

```js
import TaskForm from '@/components/TaskForm'
import TaskList from '@/components/TaskList'

const TasksPage = () => {
  return (
    <div className='max-w-lg'>
      <TaskForm />
      <TaskList />
    </div>
  )
}
export default TasksPage
```

components/TaskList

```js
import prisma from '@/utils/db'
import Link from 'next/link'
import DeleteForm from './DeleteForm'

const TaskList = async () => {
  const tasks = await prisma.task.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  })
  if (tasks.length === 0)
    return <h2 className='mt-8 font-medium text-lg'>No tasks to show</h2>
  return (
    <ul className='mt-8'>
      {tasks.map((task) => (
        <li
          key={task.id}
          className='flex justify-between items-center px-6 py-4 mb-4 border border-base-300 rounded-lg shadow-lg'
        >
          <h2
            className={`text-lg capitalize ${
              task.completed ? 'line-through' : null
            }`}
          >
            {task.content}
          </h2>
          <div className='flex gap-6 items-center'>
            <Link href={`/tasks/${task.id}`} className='btn btn-accent btn-xs'>
              edit
            </Link>
            <DeleteForm id={task.id} />
          </div>
        </li>
      ))}
    </ul>
  )
}
export default TaskList
```

## Server Actions

- asynchronous server functions that can be called directly from your components.

- typical setup for server state mutations (create, update, delete)

  - endpoint on the server (api route on Next.js)
  - make request from the front-end
    - setup form, handle submission etc

- Next.js server actions allow you to mutate server state directly from within a React component by defining server-side logic alongside client-side interactions.

Rules :

- must be async
- add 'use server' in function body
  - use only in React Server Component

```js
export default function ServerComponent() {
  async function myAction(formData) {
    'use server'
    // access input values with formData
    // formData.get('name')
    // mutate data (server)
    // revalidate cache
  }

  return <form action={myAction}>...</form>
}
```

- or setup in a separate file ('use server' at the top)
  - can use in both (RSC and RCC)

utils/actions.js

```js
'use server'

export async function myAction() {
  // ...
}
```

```js
'use client'

import { myAction } from './actions'

export default function ClientComponent() {
  return (
    <form action={myAction}>
      <button type='submit'>Add to Cart</button>
    </form>
  )
}
```

## TaskForm

```js
import prisma from '@/utils/db'
import { revalidatePath } from 'next/cache'

const createTask = async (formData) => {
  'use server'
  const content = formData.get('content')
  // some validation here

  await prisma.task.create({
    data: {
      content,
    },
  })
  // revalidate path
  revalidatePath('/tasks')
}

const TaskForm = () => {
  return (
    <form action={createTask}>
      <div className='join w-full'>
        <input
          className='input input-bordered join-item w-full'
          placeholder='Type Here'
          type='text'
          name='content'
          required
        />
        <button type='submit' className='btn join-item btn-primary'>
          create task
        </button>
      </div>
    </form>
  )
}
export default TaskForm
```

## Refactor

- create utils/actions
- move get all tasks and create task functionality
- refactor TaskForm and TaskList

```js
'use server'

import prisma from '@/utils/db'
import { revalidatePath } from 'next/cache'

export const getAllTasks = async () => {
  return prisma.task.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  })
}

export const createTask = async (formData) => {
  const content = formData.get('content')
  // some validation here

  await prisma.task.create({
    data: {
      content,
    },
  })
  // revalidate path
  revalidatePath('/tasks')
}
```

#

## DeleteForm

- will use "action" approach since it works without JS
- invoke by using startTransition (useTransition hook)

```js
import { deleteTask } from '@/utils/actions'

const DeleteForm = ({ id }) => {
  return (
    <form action={deleteTask}>
      <input type='hidden' name='id' value={id} />
      <button className='btn btn-error btn-xs'>delete</button>
    </form>
  )
}
export default DeleteForm
```

utils/actions

```js
export const deleteTask = async (formData) => {
  const id = formData.get('id')
  await prisma.task.delete({ where: { id } })
  revalidatePath('/tasks')
}
```

## Challenge - Edit Task

- create single task page
- get task info (hint:params)
- create EditForm component
- setup form with all the inputs
- render in single task page
- create server action to update task
- extra - redirect when complete

## Edit Task

tasks/[id]/page.js

```js
import EditForm from '@/components/EditForm'
import { getTask } from '@/utils/actions'
import Link from 'next/link'
const TaskPage = async ({ params }) => {
  const task = await getTask(params.id)

  return (
    <>
      <div className='mb-16'>
        <Link href='/tasks' className='btn btn-accent'>
          Back to Tasks
        </Link>
      </div>
      <EditForm task={task} />
    </>
  )
}
export default TaskPage
```

actions

```js
export const getTask = async (id) => {
  return prisma.task.findUnique({
    where: {
      id,
    },
  })
}

export const editTask = async (formData) => {
  const id = formData.get('id')
  const content = formData.get('content')
  const completed = formData.get('completed')

  await prisma.task.update({
    where: {
      id: id,
    },
    data: {
      content: content,
      completed: completed === 'on' ? true : false,
    },
  })
  // redirect won't works unless the component has 'use client'
  // another option, setup the editTask in the component directly
  redirect('/tasks')
}
```

EditForm.js

```js
'use client'
import { editTask } from '@/utils/actions'

const EditForm = ({ task }) => {
  const { id, completed, content } = task
  return (
    <form
      action={editTask}
      className='max-w-sm bg-base-100 p-12 border border-base-300  rounded-lg'
    >
      <input type='hidden' name='id' value={id} />
      {/* content */}

      <input
        type='text'
        required
        defaultValue={content}
        name='content'
        className='input input-bordered w-full'
      />

      {/* completed */}
      <div className='form-control my-4'>
        <label className='label cursor-pointer'>
          <span className='label-text'>Completed</span>
          <input
            type='checkbox'
            defaultChecked={completed}
            name='completed'
            className='checkbox checkbox-primary checkbox-sm'
          />
        </label>
      </div>
      <button className='btn btn-primary btn-block btn-sm'>edit</button>
    </form>
  )
}
export default EditForm
```
